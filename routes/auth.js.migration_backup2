const express = require('express');
const router = express.Router();
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const supabase = require('../config/supabase');
const authenticateMerchant = require('../middleware/auth');

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
const TOKEN_EXPIRY = '7d'; // 7 days

// Signup endpoint
router.post('/signup', async (req, res) => {
  try {
    const { businessName, ownerName, email, password, phoneNumber, category } = req.body;

    // Validate required fields
    if (!businessName || !ownerName || !email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Business name, owner name, email, and password are required'
      });
    }

    // Check if email already exists
    const { data: existingUser } = await supabase
      .from('portal_merchant_users')
      .select('id')
      .eq('email', email)
      .single();

    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: 'Email already registered'
      });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 10);

    // Create merchant portal user (no merchant_id yet - they'll create that in setup)
    const { data: newUser, error: userError } = await supabase
      .from('portal_merchant_users')
      .insert([{
        email,
        password_hash: passwordHash,
        full_name: ownerName,
        business_name: businessName,
        role: 'owner',
        is_active: true,
        merchant_id: null // Will be set when they create their loyalty card
      }])
      .select()
      .single();

    if (userError) {
      console.error('User creation error:', userError);
      return res.status(500).json({
        success: false,
        error: 'Failed to create account. Please try again.'
      });
    }

    console.log('‚úÖ User created successfully:', newUser.id);

    res.json({
      success: true,
      message: 'Account created successfully'
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({
      success: false,
      error: 'Signup failed. Please try again.'
    });
  }
});

// Login endpoint
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    console.log('üîê Login attempt for:', email);

    if (!email || !password) {
      return res.status(400).json({ 
        success: false, 
        error: 'Email and password are required' 
      });
    }

    // Find user by email (first get user, then get merchant separately to avoid join issues)
    const { data: user, error: userError } = await supabase
      .from('portal_merchant_users')
      .select('*')
      .eq('email', email)
      .eq('is_active', true)
      .single();

    console.log('User found:', user ? 'YES' : 'NO');
    console.log('User error:', userError?.message || 'NONE');

    if (userError || !user) {
      console.log('‚ùå User not found or error');
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid email or password' 
      });
    }

    // Get merchant data if user has a merchant_id
    if (user.merchant_id) {
      const { data: merchant } = await supabase
        .from('merchants')
        .select('id, name, logo, category, color, qr_code')
        .eq('id', user.merchant_id)
        .single();
      
      user.merchant = merchant;
      console.log('Merchant loaded:', merchant?.name || 'NO MERCHANT');
    } else {
      user.merchant = null;
      console.log('No merchant for this user yet');
    }

    // Verify password
    console.log('Checking password...');
    const validPassword = await bcrypt.compare(password, user.password_hash);
    console.log('Password valid:', validPassword);
    
    if (!validPassword) {
      console.log('‚ùå Invalid password');
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid email or password' 
      });
    }

    // Generate JWT token
    const token = jwt.sign(
      { 
        userId: user.id,
        merchantId: user.merchant_id,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRY }
    );

    // Create session in database
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days

    const { error: sessionError } = await supabase
      .from('merchant_portal_sessions')
      .insert([{
        user_id: user.id,
        merchant_id: user.merchant_id,
        token: token,
        expires_at: expiresAt.toISOString()
      }]);

    if (sessionError) {
      console.error('Session creation error:', sessionError);
    }

    // Update last login
    await supabase
      .from('portal_merchant_users')
      .update({ last_login: new Date().toISOString() })
      .eq('id', user.id);

    // Return user info and token
    res.json({
      success: true,
      data: {
        token,
        user: {
          id: user.id,
          email: user.email,
          fullName: user.full_name,
          businessName: user.business_name || user.full_name,
          role: user.role,
          createdAt: user.created_at,
          merchant: user.merchant,
          subscriptionStatus: user.subscription_status,
          subscriptionPlan: user.subscription_plan,
          stripeCustomerId: user.stripe_customer_id
        }
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Login failed. Please try again.' 
    });
  }
});

// Verify token endpoint
router.get('/verify', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ 
        success: false, 
        error: 'No token provided' 
      });
    }

    // Verify JWT
    const decoded = jwt.verify(token, JWT_SECRET);

    // Check if session exists and is valid
    const { data: session, error: sessionError } = await supabase
      .from('merchant_portal_sessions')
      .select('*')
      .eq('token', token)
      .eq('user_id', decoded.userId)
      .gt('expires_at', new Date().toISOString())
      .single();

    if (sessionError || !session) {
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid or expired session' 
      });
    }

    // Get user info
    const { data: user, error: userError } = await supabase
      .from('portal_merchant_users')
      .select('*')
      .eq('id', decoded.userId)
      .eq('is_active', true)
      .single();

    if (userError || !user) {
      return res.status(401).json({ 
        success: false, 
        error: 'User not found' 
      });
    }

    // Get merchant data if user has a merchant_id
    if (user.merchant_id) {
      const { data: merchant } = await supabase
        .from('merchants')
        .select('id, name, logo, category, color, qr_code')
        .eq('id', user.merchant_id)
        .single();
      
      user.merchant = merchant;
    } else {
      user.merchant = null;
    }

    res.json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          fullName: user.full_name,
          businessName: user.business_name || user.full_name,
          role: user.role,
          createdAt: user.created_at,
          merchant: user.merchant,
          subscriptionStatus: user.subscription_status,
          subscriptionPlan: user.subscription_plan,
          stripeCustomerId: user.stripe_customer_id
        }
      }
    });
  } catch (error) {
    console.error('Verify error:', error);
    res.status(401).json({ 
      success: false, 
      error: 'Invalid token' 
    });
  }
});

// Logout endpoint
router.post('/logout', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (token) {
      // Delete session from database
      await supabase
        .from('merchant_portal_sessions')
        .delete()
        .eq('token', token);
    }

    res.json({ success: true, message: 'Logged out successfully' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Logout failed' 
    });
  }
});

// Update profile endpoint
router.put('/profile', authenticateMerchant, async (req, res) => {
  try {
    const { businessName, currentPassword, newPassword } = req.body;
    const userId = req.merchant.userId;

    console.log('üìù Profile Update Request - User:', userId);
    console.log('Business Name:', businessName);

    // Validate required fields
    if (!businessName) {
      return res.status(400).json({
        success: false,
        error: 'Business name is required'
      });
    }

    // Get current user data
    const { data: user, error: userError } = await supabase
      .from('portal_merchant_users')
      .select('*')
      .eq('id', userId)
      .single();

    if (userError || !user) {
      console.error('User fetch error:', userError);
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // If password change requested, verify current password
    if (currentPassword && newPassword) {
      const passwordMatch = await bcrypt.compare(currentPassword, user.password_hash);
      
      if (!passwordMatch) {
        return res.status(400).json({
          success: false,
          error: 'Current password is incorrect'
        });
      }

      // Validate new password
      if (newPassword.length < 8) {
        return res.status(400).json({
          success: false,
          error: 'New password must be at least 8 characters'
        });
      }

      // Hash new password and update
      const newPasswordHash = await bcrypt.hash(newPassword, 10);
      
      const { error: passwordError } = await supabase
        .from('portal_merchant_users')
        .update({ password_hash: newPasswordHash })
        .eq('id', userId);

      if (passwordError) {
        console.error('Password update error:', passwordError);
        return res.status(500).json({
          success: false,
          error: 'Failed to update password'
        });
      }
    }

    // Update business name in merchant_portal_users table
    console.log('Updating business_name to:', businessName);
    const { error: updateError } = await supabase
      .from('portal_merchant_users')
      .update({ business_name: businessName })
      .eq('id', userId);

    if (updateError) {
      console.error('Business name update error:', updateError);
      return res.status(500).json({
        success: false,
        error: 'Failed to update business name: ' + updateError.message
      });
    }

    // Get updated user data with merchant info
    const { data: updatedUser, error: fetchError } = await supabase
      .from('portal_merchant_users')
      .select('*')
      .eq('id', userId)
      .single();

    if (fetchError || !updatedUser) {
      console.error('Fetch updated user error:', fetchError);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch updated profile'
      });
    }

    // Get merchant data if user has a merchant_id
    if (updatedUser.merchant_id) {
      const { data: merchant } = await supabase
        .from('merchants')
        .select('id, name, logo, category, color, qr_code')
        .eq('id', updatedUser.merchant_id)
        .single();
      
      updatedUser.merchant = merchant;
    } else {
      updatedUser.merchant = null;
    }

    // Generate new token with updated info
    const tokenPayload = {
      userId: updatedUser.id,
      email: updatedUser.email,
      merchantId: updatedUser.merchant_id,
      role: updatedUser.role
    };

    const newToken = jwt.sign(tokenPayload, JWT_SECRET, { expiresIn: TOKEN_EXPIRY });

    // Update session with new token
    await supabase
      .from('merchant_portal_sessions')
      .update({ token: newToken })
      .eq('user_id', userId);

    console.log('‚úÖ Profile updated successfully');
    res.json({
      success: true,
      message: 'Profile updated successfully',
      data: {
        user: {
          id: updatedUser.id,
          email: updatedUser.email,
          fullName: updatedUser.full_name,
          businessName: updatedUser.business_name || updatedUser.full_name,
          role: updatedUser.role,
          createdAt: updatedUser.created_at,
          merchant: updatedUser.merchant
        },
        token: newToken
      }
    });
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({
      success: false,
      error: 'Profile update failed: ' + error.message
    });
  }
});

module.exports = router;
